/* * Microinfinity CO. LTD.  * 05-04-2011 * The following program implements position estimation using a gyro enhanced  * odometry. The program receives basic commands using the available buttons  * for moving forward, backwards, turn left and right. The center button has  * several purposes, it allows increasing the linear speed either forward or * backwards, the direction can be set by holding the button for more than * 0.5 seconds. Holding the button also stops the robot at any time. The  * current direction of motion is constantly displayed on the robot. The left * and right buttons will make the robot turn either left or right. * *///Platform specific constants#define ENCODER_SF 0.38 //[mm/cnt]//NXT system constants#define MAX_SPEED 100 //[cnt/sec]#define SPEED_INC 5 //[cnt/sec]//XGL constants#define XGL_PORT S1#define XGL_ADDR 0x02#define XGL_ANG_REG  0x42#define XGL_RESET_REG  0x60#define XGL_PACKET 2#define XGL_CMD 2//Encoder and motor informationint last_left_cnt;int last_right_cnt;//Port settings#define LEFT_MOTOR OUT_A#define RIGHT_MOTOR OUT_Cstruct Pos {  float mX;  float mY;	float mAng;	float mDist;};//Reset XGL1300L sensorvoid XglReset(){  byte cmd[XGL_CMD];  byte n_read=0;  ArrayBuild(cmd,XGL_ADDR, XGL_RESET_REG);  while (I2CStatus(XGL_PORT, n_read) ==  STAT_COMM_PENDING);  I2CWrite(XGL_PORT,0,cmd);}//Read angle valuesshort XglReadAngle(){  byte data[XGL_PACKET];  byte cmd[XGL_CMD];  byte count=XGL_PACKET;  byte n_read=0;	short ang=0;  ArrayBuild(cmd,XGL_ADDR, XGL_ANG_REG);  while (I2CStatus(XGL_PORT, n_read) ==  STAT_COMM_PENDING);  if (I2CBytes(XGL_PORT, cmd, count, data))		ang=(data[0] + data[1]*256); //Assemble data	return -ang;}void EstimatePosition(Pos &pos){	//Get encoder information  int right_cnt = MotorRotationCount(RIGHT_MOTOR);  int left_cnt = MotorRotationCount(LEFT_MOTOR);	//Estimate linear displacement	pos.mDist = ((right_cnt-last_right_cnt)+(left_cnt-last_left_cnt))/2*ENCODER_SF;	//Get gyro data and convert it to radians	pos.mAng = XglReadAngle()/100*PI/180.0;	//Compute position	pos.mX+=pos.mDist*cos(pos.mAng);	pos.mY+=pos.mDist*sin(pos.mAng);	last_right_cnt=right_cnt;	last_left_cnt=left_cnt;}//Main programtask main(){		 ReadButtonType rbArgs;	//Timing information	int last_time;	int new_time;	int period;	int cnt=0;	int last_cnt_center=0;	bool left_bttn_pressed=false;	bool right_bttn_pressed=false;	//Positioning information	Pos pos;	float last_ang=0;		//Motor information	short dir=1;	short motor_right=0;		short motor_left=0;			//Initialization	//Resets sensor and waits for hardware to apply the command	SetSensorLowspeed(XGL_PORT);	XglReset();	Wait(500);	ClearScreen(); 	last_time=CurrentTick();	//Main loop	while(1)	{		//Computed elapsed time 		new_time=CurrentTick();		period=new_time-last_time;		last_time=new_time;				//Call position estimation function		EstimatePosition(pos);		//The rest of this program is only used to make the robot		//respond to some keyboard commands		//Change direction of motion or stop		rbArgs.Index = BTNCENTER;    SysReadButton(rbArgs);		if (rbArgs.Pressed)		{			if(!last_cnt_center)	last_cnt_center=cnt;			if(last_cnt_center>0 && (cnt-last_cnt_center)>3)			{ //If the center button has been pressed long enough, stop				motor_left=0;				motor_right=0;				dir=(dir==1)?-1:1; 				last_cnt_center=-1;			}		}		else if(last_cnt_center>0)		{ //If center button was pressed and released quickly, increase speed in the last direction			motor_left+=SPEED_INC*dir;			motor_right+=SPEED_INC*dir;			last_cnt_center=0;		}		//If robot was stop, reset counter status		else if(last_cnt_center<0) last_cnt_center=0;		//Detect when the left button is pressed and increase the rate of turn accordingly				rbArgs.Index = BTNLEFT;    SysReadButton(rbArgs);		if (rbArgs.Pressed)			left_bttn_pressed=true;		else if(left_bttn_pressed)		{//When left button is released			motor_left+=SPEED_INC*dir;			motor_right-=SPEED_INC*dir;			left_bttn_pressed=false;		}		//Detect when the right button is pressed and increase the rate of turn accordingly				rbArgs.Index = BTNRIGHT;    SysReadButton(rbArgs);		if (rbArgs.Pressed)			right_bttn_pressed=true;		else if(right_bttn_pressed)		{//When right button is released			motor_left-=SPEED_INC*dir;			motor_right+=SPEED_INC*dir;			right_bttn_pressed=false;		} 				//Send motor command		OnFwdReg(RIGHT_MOTOR, motor_right, OUT_REGMODE_SPEED);		OnFwdReg(LEFT_MOTOR, motor_left, OUT_REGMODE_SPEED);		//Display important information about the robot		NumOut(0,LCD_LINE1,period*cnt/1000);    NumOut(60,LCD_LINE1,period);		if(dir==1) TextOut(0, LCD_LINE2,"FORWARD  ", false);		else TextOut(0, LCD_LINE2,"BACKWARDS", false);		TextOut(0, LCD_LINE4, "X[mm]:          ", false);    NumOut(60,LCD_LINE4,pos.mX);		TextOut(0, LCD_LINE5, "Y[mm]:          ", false);    NumOut(60,LCD_LINE5,pos.mY);		TextOut(0, LCD_LINE6, "H[deg]:          ", false);    NumOut(60,LCD_LINE6,pos.mAng*180.0/PI);		TextOut(0, LCD_LINE7, "V[mm/s]:          ", false);    NumOut(60,LCD_LINE7,pos.mDist/period*1000);		TextOut(0, LCD_LINE8, "W[deg/s]:          ", false);    NumOut(60,LCD_LINE8,(last_ang-pos.mAng)/period*180/PI*1000);			last_ang=pos.mAng;		cnt++;		Wait(80);	}}