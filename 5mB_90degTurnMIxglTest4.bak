/* * Microinfinity CO. LTD. * Test program for the XGL1300L device * This program displays the complete data package from the device * it resets the sensor when the user press the left button * it changes the accelerometer SF when the user press the right button*/// v2 - split reading of gyro, display and motor movements into separate tasks// v3 - add PID for motor speed// v4 - add motor speed ramp up/down feature//Define constants#define XGL_PORT S1#define XGL_ADDR 0x02#define XGL_DATA_REG  0x42#define XGL_RESET_REG  0x60#define XGL_ACC_SF_REG  0x61#define XGL_DATA_PACKET 10#define XGL_COMMAND 2#define XGL_TIME_OUT 500//XGL1300L sensor data packetstruct XGLpacket{	short mAng;	short mRate;	short mAccX;	short mAccY;	short mAccZ;};XGLpacket xgl;//Reset XGL1300L sensorvoid XglReset(){	byte cmd[XGL_COMMAND];	byte n_read=0;	ArrayBuild(cmd,XGL_ADDR, XGL_RESET_REG);	while (I2CStatus(XGL_PORT, n_read) ==  STAT_COMM_PENDING);	I2CWrite(XGL_PORT,0,cmd);}//Change scale factor, the accSf parameter can be// 0 -> +/- 2G// 1 -> +/- 4G// 2 -> +/- 8gvoid XglAccSF(byte accSf){	byte cmd[XGL_COMMAND];	byte n_read=0;	byte register= XGL_ACC_SF_REG+accSf;	ArrayBuild(cmd,XGL_ADDR, register);	while (I2CStatus(XGL_PORT, n_read) ==  STAT_COMM_PENDING);	I2CWrite(XGL_PORT,0,cmd);}//Reads the full packet from XGL1300Lvoid XglReadPacket(XGLpacket &XglData){	byte data[XGL_DATA_PACKET];	byte cmd[XGL_COMMAND];	byte count=XGL_DATA_PACKET;	byte n_read=0;	ArrayBuild(cmd,XGL_ADDR, XGL_DATA_REG);	while (I2CStatus(XGL_PORT, n_read) ==  STAT_COMM_PENDING);	if (I2CBytes(XGL_PORT, cmd, count, data))	{//Assemble data		XglData.mAng = data[0] + data[1]*256;		XglData.mRate = data[2] + data[3]*256;		XglData.mAccX = data[4] + data[5]*256;		XglData.mAccY = data[6] + data[7]*256;		XglData.mAccZ = data[8] + data[9]*256;	}}//define global varsshort target=4500;  task move(){  int pwr=20;  int dir=1;    //move motor until angle diff is below threshold  while (1)  {    if (abs(target-xgl.mAng)<100)    //pointing in the right direction now    //stop the motor(s), reset pwr, update target and direction    {      Off(OUT_B);      PlayTone(440, 125);      target=target*-1;      dir=dir*-1;      pwr=20;      Wait(5000);    }    else    //keep moving at motor speed based on angle diff    //limit upper and lower pwr (speed) levels    {      if (abs(target-xgl.mAng)>3000)      {        pwr+=1;      }      else      {        pwr-=3;      }      if (pwr>50)      {        pwr=50;      }      if (pwr<20)      {        pwr=20;      }      OnFwd(OUT_B, dir*pwr);    }    Wait(50);  }}task readGyro(){  while (1)  {    XglReadPacket(xgl);    Wait(50);  }}task disply(){	while (1)	{		ClearScreen();		TextOut(0, LCD_LINE1,"<RESET / ACC_SF>", false);		//Print Angle  value		TextOut(0, LCD_LINE3,"ANGLE:");		NumOut(40, LCD_LINE3,xgl.mAng);		//Print Angle  value		TextOut(0, LCD_LINE3,"abs Diff to target:");		NumOut(40, LCD_LINE4,abs(target-xgl.mAng));    //Print Rate value		//TextOut(0, LCD_LINE4,"RATE:");		//NumOut(40, LCD_LINE4,xgl.mRate);		//Print Acc x value		TextOut(0, LCD_LINE5,"ACC_X:");		NumOut(40, LCD_LINE5,xgl.mAccX);		//Print Acc y value		TextOut(0, LCD_LINE6,"ACC_Y:");		NumOut(40, LCD_LINE6,xgl.mAccY);		//Print Acc z value		TextOut(0, LCD_LINE7,"ACC_Z:");		NumOut(40, LCD_LINE7,xgl.mAccZ);    Wait(50);  }}task main(){	byte acc_sf=0;	ReadButtonType rbArgs;	//Initialize system	SetSensorLowspeed(XGL_PORT);	//Resets sensor and waits for hardware to settle	XglReset();	Wait(XGL_TIME_OUT);    //start tasks  start readGyro;  start disply;  start move;	//Main loop	while (1)	{		//Reset sensor if user press left key		rbArgs.Index = BTNLEFT;		SysReadButton(rbArgs);		if (rbArgs.Pressed)		{			XglReset();			TextOut(0, LCD_LINE2,"Reseting XGL ...", false);			Wait(XGL_TIME_OUT);		}		//Change accelerometer SF if user press right key		rbArgs.Index = BTNRIGHT;		SysReadButton(rbArgs);		if (rbArgs.Pressed)		{			acc_sf=(acc_sf==2)?0:acc_sf+1;			XglAccSF(acc_sf);			TextOut(0, LCD_LINE2,"Accel SF +/-");			NumOut(75, LCD_LINE2,2<<acc_sf);			Wait(XGL_TIME_OUT);		}		Wait(200);	}}